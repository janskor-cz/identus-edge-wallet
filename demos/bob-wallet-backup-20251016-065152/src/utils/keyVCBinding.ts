/**
 * Key-VC Binding Verification
 *
 * Ensures that encryption keys are cryptographically bound to Security Clearance
 * Verifiable Credentials via public key fingerprinting.
 */

import { SecurityKey, SecurityKeyStorage } from '../types/securityKeys';
import { loadSecurityKeys } from './securityKeyStorage';
import { SecurityLevel, parseSecurityLevel } from './securityLevels';

/**
 * Verify that a security key is bound to a Security Clearance VC
 * by comparing fingerprints.
 *
 * The VC contains a keyFingerprint field that must match the fingerprint
 * of the stored private key. This ensures the key was generated by the
 * user and is legitimately associated with the VC.
 *
 * @param securityKey - The security key from localStorage
 * @param securityClearanceVC - The Security Clearance Verifiable Credential
 * @returns true if fingerprints match, false otherwise
 *
 * @example
 * const key = getSecurityKeyByFingerprint("AB:CD:EF:...");
 * const vc = credentials.find(c => c.type.includes('SecurityClearanceCredential'));
 * if (verifyKeyVCBinding(key, vc)) {
 *   // Key is bound to VC - safe to use for encryption
 * }
 */
export function verifyKeyVCBinding(
  securityKey: SecurityKey,
  securityClearanceVC: any
): boolean {
  const vcFingerprint = securityClearanceVC?.credentialSubject?.keyFingerprint;

  if (!vcFingerprint) {
    console.error('❌ [keyVCBinding] Security Clearance VC missing keyFingerprint');
    return false;
  }

  if (!securityKey) {
    console.error('❌ [keyVCBinding] Security key is null or undefined');
    return false;
  }

  if (securityKey.fingerprint !== vcFingerprint) {
    console.error('❌ [keyVCBinding] Key fingerprint mismatch', {
      keyFingerprint: securityKey.fingerprint,
      vcFingerprint: vcFingerprint
    });
    return false;
  }

  console.log('✅ [keyVCBinding] Key-VC binding verified', {
    fingerprint: vcFingerprint.substring(0, 20) + '...'
  });

  return true;
}

/**
 * Extract the clearance level from a Security Clearance VC
 *
 * @param vc - Security Clearance Verifiable Credential
 * @returns SecurityLevel enum value
 *
 * @example
 * const vc = credentials.find(c => c.type.includes('SecurityClearanceCredential'));
 * const level = getVCClearanceLevel(vc);
 * // SecurityLevel.SECRET
 */
export function getVCClearanceLevel(vc: any): SecurityLevel {
  if (!vc) {
    console.warn('⚠️ [keyVCBinding] No VC provided, defaulting to UNCLASSIFIED');
    return SecurityLevel.UNCLASSIFIED;
  }

  const clearanceLevelStr = vc.credentialSubject?.clearanceLevel;

  if (!clearanceLevelStr) {
    console.warn('⚠️ [keyVCBinding] VC missing clearanceLevel, defaulting to UNCLASSIFIED');
    return SecurityLevel.UNCLASSIFIED;
  }

  return parseSecurityLevel(clearanceLevelStr);
}

/**
 * Retrieve a security key from localStorage by its fingerprint
 *
 * This is used to find the private key that corresponds to a public key
 * fingerprint embedded in a Security Clearance VC.
 *
 * @param fingerprint - Public key fingerprint (format: "AB:CD:EF:...")
 * @returns SecurityKey if found, undefined otherwise
 *
 * @example
 * const vc = credentials.find(c => c.type.includes('SecurityClearanceCredential'));
 * const fingerprint = vc.credentialSubject.keyFingerprint;
 * const key = getSecurityKeyByFingerprint(fingerprint);
 * if (key) {
 *   // Use key.privateKeyBytes for encryption
 * }
 */
export function getSecurityKeyByFingerprint(fingerprint: string): SecurityKey | undefined {
  const storage: SecurityKeyStorage = loadSecurityKeys();

  const key = storage.keys.find(k => k.fingerprint === fingerprint);

  if (!key) {
    console.warn(`⚠️ [keyVCBinding] No security key found for fingerprint: ${fingerprint.substring(0, 20)}...`);
    return undefined;
  }

  console.log('✅ [keyVCBinding] Security key retrieved', {
    keyId: key.keyId,
    fingerprint: fingerprint.substring(0, 20) + '...'
  });

  return key;
}

/**
 * Validate that a user has a Security Clearance VC with a bound key
 * for a given clearance level.
 *
 * @param credentials - Array of credentials from wallet state
 * @param requiredLevel - Minimum required clearance level
 * @returns Object with validation result and details
 *
 * @example
 * const result = validateUserClearance(credentials, SecurityLevel.SECRET);
 * if (!result.valid) {
 *   alert(result.error);
 * } else {
 *   // Use result.vc and result.key for encryption
 * }
 */
export function validateUserClearance(
  credentials: any[],
  requiredLevel: SecurityLevel
): {
  valid: boolean;
  vc?: any;
  key?: SecurityKey;
  clearanceLevel?: SecurityLevel;
  error?: string;
} {
  // Find Security Clearance VC
  const securityVC = credentials.find(cred =>
    cred.type?.includes('SecurityClearanceCredential')
  );

  if (!securityVC) {
    return {
      valid: false,
      error: 'No Security Clearance VC found. Cannot send classified messages.'
    };
  }

  // Get clearance level
  const userClearance = getVCClearanceLevel(securityVC);

  if (userClearance < requiredLevel) {
    return {
      valid: false,
      vc: securityVC,
      clearanceLevel: userClearance,
      error: `Insufficient clearance. You have ${SecurityLevel[userClearance]} but need ${SecurityLevel[requiredLevel]}.`
    };
  }

  // Get bound key
  const vcFingerprint = securityVC.credentialSubject?.keyFingerprint;
  if (!vcFingerprint) {
    return {
      valid: false,
      vc: securityVC,
      clearanceLevel: userClearance,
      error: 'Security Clearance VC missing key fingerprint. VC may be invalid.'
    };
  }

  const boundKey = getSecurityKeyByFingerprint(vcFingerprint);
  if (!boundKey) {
    return {
      valid: false,
      vc: securityVC,
      clearanceLevel: userClearance,
      error: 'Private key not found. VC may have been revoked or key deleted.'
    };
  }

  // Verify binding
  if (!verifyKeyVCBinding(boundKey, securityVC)) {
    return {
      valid: false,
      vc: securityVC,
      clearanceLevel: userClearance,
      error: 'Key-VC binding verification failed. Security violation detected.'
    };
  }

  return {
    valid: true,
    vc: securityVC,
    key: boundKey,
    clearanceLevel: userClearance
  };
}

/**
 * Extract public key from a Security Clearance VC
 *
 * @param vc - Security Clearance Verifiable Credential
 * @returns Public key bytes as base64url string, or undefined if not found
 */
export function getVCPublicKey(vc: any): string | undefined {
  return vc?.credentialSubject?.publicKey;
}

/**
 * Check if a Security Clearance VC has expired
 *
 * @param vc - Security Clearance Verifiable Credential
 * @returns true if expired, false if still valid
 */
export function isVCExpired(vc: any): boolean {
  const validUntil = vc?.credentialSubject?.validUntil;

  if (!validUntil) {
    return false; // No expiry date means no expiration
  }

  return new Date(validUntil) < new Date();
}
